#!/bin/bash

VERBOSE=1
STRICT=1
ROOT_PREFIX=

(( __KB = 1024 ))
(( __MB = 1024 * 1024 ))
(( __GB = 1024 * 1024 * 1024 ))

# ------------------------------------------------------------------------------------------------
# Utility Functions Start (db4de81e-a31e-491d-a9dc-17a3e63be914)
# ------------------------------------------------------------------------------------------------

#
# on_linux
#     major_kernel_version : out
#     major_kernel_version : out
#
# Places the major kernel version in the first argument and the minor version
# in the second argument.
#
function on_linux()
{
    if [ "$(uname | tr [:upper:] [:lower:])" = "linux" ]; then
        return 0
    else
        return 1
    fi
}

#
# which_linux
#     distro_string : out
#     distro        : out
#
# Places the distro name in the first argument and a short-form name (i.e., ubuntu or fedora)
# in the second argument.
#
function which_linux()
{
    local -n __wl_distro_str_out=$1
    local -n __wl_distro_out=$2
    local __wl_hd
    local __wl_md

    if [[ -f "${ROOT_PREFIX}"/etc/os-release ]]; then
        __wl_hd=$(awk -F= '/^NAME/{print $2}' "${ROOT_PREFIX}"/etc/os-release | tr -d \")
        __wl_md=$( echo "${__wl_hd}" | cut -d ' ' -f 1 | tr [:upper:] [:lower:] )
    else
        __wl_hd=unknown
        __wl_md=unknown
    fi

    __wl_distro_str_out=${__wl_hd}
    __wl_distro_out=${__wl_md}
}

function version_to_major_minor()
{
    local __vtmm_version_str=${1}
    local -n __vtmm_major_ver_out=${2}
    local -n __vtmm_minor_ver_out=${3}

    local __vtmm_major_ver
    local __vtmm_minor_ver

    if [[ "${__vtmm_version_str}" =~ ([[:digit:]]+)\.([[:digit:]]+) ]] ; then
        __vtmm_major_ver=${BASH_REMATCH[1]}
        __vtmm_minor_ver=${BASH_REMATCH[2]}
    elif [[ "${__vtmm_version_str}" =~ ([[:digit:]]+) ]] ; then
        __vtmm_major_ver=${BASH_REMATCH[1]}
        __vtmm_minor_ver=0
    fi

    __vtmm_major_ver_out=${__vtmm_major_ver}
    __vtmm_minor_ver_out=${__vtmm_minor_ver}
}

#
# version_gt
#     lhs_major_version : in
#     lhs_minor_version : in
#     rhs_major_version : in
#     rhs_minor_version : in
#
# Returns shell true/false if the left hand side major/minor version pair is greater
# than the right hand side major/minor version pair.
#
function version_gt()
{
    local lhs_major=${1}
    local lhs_minor=${2}
    local rhs_major=${3}
    local rhs_minor=${4}

    if [[ "${lhs_major}" -gt "${rhs_major}" ]]; then
        return 0
    elif [[ "${lhs_major}" -eq "${rhs_major}" && \
            "${lhs_minor}" -gt "${rhs_minor}"  ]]; then
        return 0
    else
        return 1
    fi
}

#
# version_gte
#     lhs_major_version : in
#     lhs_minor_version : in
#     rhs_major_version : in
#     rhs_minor_version : in
#
# Returns shell true/false if the left hand side major/minor version pair is greater
# than or equal to the right hand side major/minor version pair.
#
function version_gte()
{
    local lhs_major=${1}
    local lhs_minor=${2}
    local rhs_major=${3}
    local rhs_minor=${4}

    if [[ "${lhs_major}" -gt "${rhs_major}" ]]; then
        return 0
    elif [[ "${lhs_major}" -eq "${rhs_major}" &&   \
            ( "${lhs_minor}" -gt "${rhs_minor}" || \
              "${lhs_minor}" -eq "${rhs_minor}" ) ]]; then
        return 0
    else
        return 1
    fi
}

#
# min_kernel_version
#     minimum_major_version : in
#     minimum_minor_version : in
#
# Returns shell true/false based on whether the currently running kernel meets the
# minimum version specified by the caller.
#
function min_kernel_ver()
{
    local min_major=$1
    local min_minor=$2
    local kv_major
    local kv_minor

    version_to_major_minor "$(uname -r)" kv_major kv_minor
    if version_gte "${kv_major}" "${kv_minor}" "${min_major}" "${min_minor}" ; then
        return 0
    else
        return 1
    fi
}

#
# get_kernel_cxl_options
#     config : in
#
# NOTE - This function relies on a global associative array called CXL_OPTIONS
#
# This function scans the kernel configuration file passed as an argument, looking
# for CXL options. It has a set of known variables that it is looking for but will
# add others to the array if they are found.
#
function get_kernel_cxl_options()
{
    local config=${1}
    local setting

    CXL_OPTIONS[CONFIG_CXL_BUS]=""
    CXL_OPTIONS[CONFIG_CXL_PCI]=""
    CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS]=""
    CXL_OPTIONS[CONFIG_CXL_ACPI]=""
    CXL_OPTIONS[CONFIG_CXL_PMEM]=""
    CXL_OPTIONS[CONFIG_CXL_MEM]=""
    CXL_OPTIONS[CONFIG_CXL_PORT]=""
    CXL_OPTIONS[CONFIG_CXL_REGION]=""

    if [[ -f "${config}" && -r "${config}" ]]; then
        while read setting; do
            if [[ "${setting}" =~ (CONFIG_CXL_[[:alpha:]_]+)[[:space:]]*=[[:space:]]*([[:alnum:]]+) ]] ; then
                CXL_OPTIONS[${BASH_REMATCH[1]}]=${BASH_REMATCH[2]}
            fi
        done < <(grep CONFIG_CXL "${config}")
    fi
}

#
# get_cxl_devce_info
#
# NOTE - This function relies on a global associative array called CXL_DEVICES
#
# This function finds the devices in /sys/bus/cxl and attempts to learn everything
# it can about them.
#
function get_cxl_device_info()
{
    local device_entries
    local device_entry
    local tmp_array
    local module_name
    local module_pcie_dev
    local pcie_link_string

    CXL_SYSFS_ROOT=/sys/bus/cxl
    if [[ -d ${CXL_SYSFS_ROOT} && -x ${CXL_SYSFS_ROOT}/devices ]]; then
        devices_entries=$(ls -l ${CXL_SYSFS_ROOT}/devices | tail -n +2)
        while read -r device_entry; do
            read -ra tmp_array <<<${device_entry}
            if (( ${#tmp_array[@]} == 11 )) ; then
                module_name=${tmp_array[8]}
                pcie_link_string=${tmp_array[10]}
                if [[ ${pcie_link_string} =~ ../../../devices/[^/]+/([^/]+)/([[:alnum:]]+) ]] ; then
                    module_pcie_dev=${BASH_REMATCH[1]}
                else
                    echo "Warning - CXL device detected with an unrecognized PCIe device link:"
                    echo "              ${pcie_link_string}"
                    echo "          Device will be ignored."
                    continue
                fi
                CXL_DEVICES["${module_name}"]="${module_pcie_dev}"
            else
                echo "Warning - Device listing in ${CXL_SYSFS_ROOT}/devices in unknown format:"
                echo "              ${device_entry}"
                echo "          Device will be ignored."
                continue
            fi
        done <<< "${devices_entries}"
    fi
}

#
# deb_package_check
#     package_name       : in
#     package_installed  : out
#     package_version    : out
#     package_upgradable : out
#
# Checks whether the package given by the supplied name is installed and sets the second
# argument to 0/1 accordingly. If it is installed, then the third argument and fourth
# arguments respectively are set to the major and minor version of the package. The fifth
# argument is set to 0/1 if the package is-not/is currently upgradable
#
function deb_package_check()
{
    local __dpc_package_nm=$1
    local -n __dpc_installed_out=$2
    local -n __dpc_major_ver_out=$3
    local -n __dpc_minor_ver_out=$4
    local -n __dpc_upgradable_out=$5

    local __dpc_installed
    local __dpc_major_ver
    local __dpc_minor_ver
    local __dpc_upgradable
    
    if dpkg -s "${__dpc_package_nm}" > /dev/null 2>&1 ; then
        __dpc_installed=1
    else
        __dpc_installed=0
        __dpc_major_ver=0
        __dpc_minor_ver=0
        __dpc_upgradable=0
    fi

    if (( "${__dpc_installed}" == 1 )); then
        local __dpc_tmp=$(dpkg -s "${__dpc_package_nm}" | grep Version | cut -d ' ' -f 2)
        if [[ "${__dpc_tmp}" =~ ([0-9]+):(.*) ]] ; then
            # there is an epoch for the version, ignore it
            __dpc_tmp=${BASH_REMATCH[2]}
            if [[ "${__dpc_tmp}" =~ (.*)-([[:alnum:]]*) ]] ; then
                # there a debian version string on the end, ignore it
                __dpc_tmp=${BASH_REMATCH[1]}
            fi
        fi

        version_to_major_minor "${__dpc_tmp}" __dpc_major_ver __dpc_minor_ver

        if apt-get -s upgrade | grep "${__dpc_package_nm}" > /dev/null 2>&1 ; then
           __dpc_upgradable=1
        else
           __dpc_upgradable=0
        fi
    fi

    __dpc_installed_out=${__dpc_installed}
    __dpc_major_ver_out=${__dpc_major_ver}
    __dpc_minor_ver_out=${__dpc_minor_ver}
    __dpc_upgradable_out=${__dpc_upgradable}
}

#
# rpm_check_upgradable
#     package_name          : in
#     package_major_version : in
#     package_minor_version : in
#
# Checks whether the package given by the supplied name is upgradable, defined as being
# Returns shell true/false if the package given by the supplied name is upgradable.
# A package is upgradable if dnf lists a version that is greater than the given version
#
function rpm_check_upgradable()
{
    local package_nm=$1
    local curr_major_ver=$2
    local curr_minor_ver=$3

    local tmp_major_ver
    local tmp_minor_ver
    local version

    for version in $(dnf -C -q --showduplicates list --available  "${package_nm}" | \
                       grep "${package_nm}" 2>&1                                  | \
                       tr -s " "                                                  | \
                       cut -d ' ' -f 2)
    do
        version_to_major_minor "${version}" tmp_major_ver tmp_minor_ver
        if version_gt "${tmp_major_ver}"  "${tmp_minor_ver}" \
                      "${curr_major_ver}" "${curr_major_ver}" ; then
            return 0
        fi
    done

    return 1
}

#
# rpm_package_check
#     package_name       : in
#     package_installed  : out
#     package_version    : out
#     package_upgradable : out
#
# Checks whether the package given by the supplied name is installed and sets the second
# argument to 0/1 accordingly. If it is installed, then the third argument and fourth
# arguments respectively are set to the major and minor version of the package. The fifth
# argument is set to 0/1 if the package is-not/is currently upgradable
#
function rpm_package_check()
{
    local __rpc_package_nm=$1
    local -n __rpc_installed_out=$2
    local -n __rpc_major_ver_out=$3
    local -n __rpc_minor_ver_out=$4
    local -n __rpc_upgradable_out=$5

    local __rpc_installed
    local __rpc_major_ver
    local __rpc_minor_ver
    local __rpc_upgradable

    if rpm -q -s "${__rpc_package_nm}" > /dev/null 2>&1 ; then
        __rpc_installed=1
    else
        __rpc_installed=0
        __rpc_major_ver=0
        __rpc_minor_ver=0
        __rpc_upgradable=0
    fi

    if (( "${__rpc_installed}" == 1 )); then
        local __rpc_tmp=$(rpm -q --queryformat '%{VERSION}' "${__rpc_package_nm}")
        if [[ "${__rpc_tmp}" =~ ([[:digit:]]+).([[:digit:]]+) ]] ; then
            __rpc_major_ver=${BASH_REMATCH[1]}
            __rpc_minor_ver=${BASH_REMATCH[2]}
        elif [[ "${__rpc_tmp}" =~ ([[:digit:]]+) ]] ; then
            __rpc_major_ver=${BASH_REMATCH[1]}
            __rpc_minor_ver=0
        fi

        if rpm_check_upgradable "${__rpc_package_nm}" "${__rpc_major_ver}" "${__rpc_minor_ver}" ; then
            __rpc_upgradable=1
        else
            __rpc_upgradable=0
        fi
    fi

    __rpc_installed_out=${__rpc_installed}
    __rpc_major_ver_out=${__rpc_major_ver}
    __rpc_minor_ver_out=${__rpc_minor_ver}
    __rpc_upgradable_out=${__rpc_upgradable}
}

# ------------------------------------------------------------------------------------------------
# Utility Functions End (db4de81e-a31e-491d-a9dc-17a3e63be914)
# ------------------------------------------------------------------------------------------------



# ------------------------------------------------------------------------------------------------
#
# Primary Execution Sequence
#
# ------------------------------------------------------------------------------------------------

#
# Check if the system is running Linux
#
on_linux
if [ $? -ne 0 ]; then
    echo "${0} is only supported on Linux, exiting"
    exit 1
fi


#
# Check to see whether we booted via UEFI or BIOS
#

if [[ -d "${ROOT_PREFIX}"/sys/firmware/efi ]]; then
    UEFI_MODE=1
    (( "${VERBOSE}" == 1 )) && echo "System booted using UEFI"
else
    UEFI_MODE=0
    (( "${VERBOSE}" == 1 )) && echo "System booted using BIOS"
fi


#
# Vet the OS installation and kernel version
#

KERNEL_MAJOR_VER_MIN=5
KERNEL_MINOR_VER_MIN=15
KERNEL_VER_MIN_STR=${KERNEL_MAJOR_VER_MIN}.${KERNEL_MINOR_VER_MIN}

# Set up the distro information
which_linux LINUX_DISTRO_STR LINUX_DISTRO
(( "${VERBOSE}" == 1 )) && echo "Detected ${LINUX_DISTRO_STR}"
if [ "${LINUX_DISTRO}" != ubuntu -a "${LINUX_DISTRO}" != fedora ]; then
    echo "Warning - Running one of Fedora Core (version 36 or later) or Ubuntu"
    echo "          (version 22.04 LTS or later) is suggested"
    if (( "${STRICT}" == 1 )); then
        exit 1
    fi
fi

# Check if the kernel meets the minimum version requirement
MIN_KERNEL_VER_MET=0
min_kernel_ver "${KERNEL_MAJOR_VER_MIN}" "${KERNEL_MINOR_VER_MIN}"
if [ $? -ne 0 ]; then
    echo "Warning - Minimum kernel version requirement not met. Currently running"
    echo "          kernel version $(uname -r) while a kernel of at least version"
    echo "          ${KERNEL_VER_MIN_STR} is recommended"
else
    MIN_KERNEL_VER_MET=1
    (( "${VERBOSE}" == 1 )) && echo "Minimum kernel version requirement met - $(uname -r) vs. ${KERNEL_VER_MIN_STR}"
fi

# Check for kernel boot configuration
KERN_VER=$(uname -r)
KERN_CFG=${ROOT_PREFIX}/boot/config-${KERN_VER}
KERNEL_CFG_KNOWN=0
if [[ ! -f ${KERN_CFG} ]]; then
    echo "Kernel compile configuration not in known location, expected ${KERN_CFG}"
    echo "    The kernel compile options are unknown."
    if (( "${STRICT}" == 1 )); then
        exit 1
    fi
else
    (( "${VERBOSE}" == 1 )) && echo "Kernel boot configuration located (${KERN_CFG})"
    KERNEL_CFG_KNOWN=1
fi

#
# Vet available packages
#
# Currently we are only looking for daxctl
#

DAXCTL_USABLE=0

DAXCTL_MAJ_VER_MIN=74
DAXCTL_MIN_VER_MIN=0
DAXCTL_VER_MIN="${DAXCTL_MAJ_VER_MIN}.${DAXCTL_MIN_VER_MIN}"

if [[ "${LINUX_DISTRO}" == ubuntu ]]; then
    deb_package_check daxctll DAXCTL_PRESENT DAXCTL_MAJOR_VER DAXCTL_MINOR_VER DAXCTL_UPGRADABLE
else
    rpm_package_check daxctl DAXCTL_PRESENT DAXCTL_MAJOR_VER DAXCTL_MINOR_VER DAXCTL_UPGRADABLE
fi

echo
if (( "${DAXCTL_PRESENT}" == 0 )) ; then
    echo "Package daxctl does not appear to be installed. Please install the latest"
    echo "version or at least version ${DAXCTL_VER_MIN}. If not available then compile from"
    echo "source."
else
    if version_gte "${DAXCTL_MAJOR_VER}" "${DAXCTL_MINOR_VER}" "${DAXCTL_MAJ_VER_MIN}" "${DAXCTL_MIN_VER_MIN}" ; then
        DAXCTL_USABLE=1
        (( "${VERBOSE}" == 1 )) && echo "The package daxctl is installed and at a sufficient version."
    else
        echo "The package daxctl is installed but at a version that is too old."
        if (( ${DAXCTL_UPGRADABLE} == 1 )) ; then
            echo "The package daxctl can be upgraded, please upgrade and re-run ${0}."
        else
            echo "The package daxctl can't be upgraded, please compile and install daxctl"
            echo "and re-run ${0}."
        fi
    fi
    (( "${VERBOSE}" == 1 )) && echo "daxctl version: ${DAXCTL_MAJOR_VER}.${DAXCTL_MINOR_VER}"
fi


#
# CXL device checks
#

declare -A CXL_DEVICES
get_cxl_device_info

echo -e "\nDetecting CXL devices ..."
for device in ${!CXL_DEVICES[@]} ; do
    address="${CXL_DEVICES[${device}]}"
    vendor=
    device_id=
    lspci_begin_line=$(lspci -D -mm -vv | grep -n ${CXL_DEVICES[${device}]} | cut -d : -f 1)
    lspci_block=$(lspci -D -mm -vv | tail -n +${lspci_begin_line} | sed '/^$/Q')
    while read -r lspci_field; do
        label=$(echo "${lspci_field}" | cut -d : -f 1 | tr -d " " )
        value=$(echo "${lspci_field}" | cut -d : -f 2 | tr -d "\t" | sed -r 's/^( )//g')
        if [[ "${label}" == Class && "${value}" != CXL ]] ; then
            echo "Warning - Apparent device class mismatch for ${device}, expected CXL. Got"
            echo "          ${value}"
        fi
        if [[ "${label}" == Vendor ]] ; then
            vendor="${value}"
        fi
        if [[ "${label}" == Device ]] ; then
            device_id="${value}"
        fi
    done <<< "${lspci_block}"

    device_size="<unknown>"
    if [[ "${CXL_DEVICES[${device}]}" =~ ([[:alnum:]]+):([[:alnum:]]+): ]] ; then
        pcie_group="${BASH_REMATCH[1]}"
        pcie_devid="${BASH_REMATCH[2]}"
        size_file="/sys/devices/pci${pcie_group}:${pcie_devid}/${address}/${device}/ram/size"
        if [[ -f "${size_file}" && -r "${size_file}" ]] ; then
            device_size=$(cat "${size_file}")
        fi
    fi

    if [[ "${device_size}" != "<unknown>" ]] ; then
        (( device_size = (device_size / __GB) ))
    fi

    echo -e "            CXL Device : ${device}"
    echo -e "                Vendor : ${vendor}"
    echo -e "             Device ID : ${device_id}"
    echo -e "               Address : ${CXL_DEVICES[${device}]}"
    echo -e "                  Size : ${device_size} GB"
    echo -ne "       Mailbox Present : "

    if [[ -c "/dev/cxl/${device}" ]] ; then
        echo -e "yes"
    else
        echo -e "no"
    fi
    echo -e ""
done


#
# DAX device checks
#
#if (( "${DAXCTL_USABLE}" == 1 )); then
#
#fi

# At this point we know we're running some variation of the minimum kernel version and
# we may know whether the kernel was configured with CXL support. Next we attempt to
# determine whether the kernel appears to actually be running with CXL support.

CXLSTAT_MAILBOX_ENABLED=0
CXLSTAT_MAILBOX_RAW_ENABLED=0

# Attempt to obtain CXL options
declare -A CXL_OPTIONS
get_kernel_cxl_options "${KERN_CFG}"

echo
if (( "${VERBOSE}" == 1 )) ; then
    if [[ "${CXL_OPTIONS[CONFIG_CXL_MEM]}" == y ||
          "${CXL_OPTIONS[CONFIG_CXL_MEM]}" == m ]] ; then
        CXLSTAT_MAILBOX_ENABLED=1
        if [[ "${CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS]}" == y ||
              "${CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS]}" == m ]] ; then
            CXLSTAT_MAILBOX_RAW_ENABLED=1
            echo "Standard and vendor-specific CXL mailbox commands may be used"
        else
            echo "Standard CXL mailbox commands may be used"
        fi
    else
        echo "No clear kernel support for CXL devices"
    fi
fi

exit 0
