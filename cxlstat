#!/bin/bash

VERBOSE=1
STRICT=1

ROOT_PREFIX=

# ------------------------------------------------------------------------------------------------
# Utility Functions Start (db4de81e-a31e-491d-a9dc-17a3e63be914)
# ------------------------------------------------------------------------------------------------

#
# on_linux
#     major_kernel_version : out
#     major_kernel_version : out
#
# Places the major kernel version in the first argument and the minor version
# in the second argument.
#
function on_linux()
{
    if [ $(uname | tr [:upper:] [:lower:]) = "linux" ]; then
        return 0
    else
        return 1
    fi
}

#
# which_linux
#     distro_string : out
#     distro        : out
#
# Places the distro name in the first argument and a short-form name (i.e., ubuntu or fedora)
# in the second argument.
#
function which_linux()
{
    local __wl_distro_str_out=$1
    local __wl_distro_out=$2
    local __wl_hd
    local __wl_md

    if [[ -f ${ROOT_PREFIX}/etc/os-release ]]; then
        __wl_hd=$(awk -F= '/^NAME/{print $2}' ${ROOT_PREFIX}/etc/os-release | tr -d \")
        __wl_md=$( echo ${__wl_hd} | cut -d ' ' -f 1 | tr [:upper:] [:lower:] )
    else
        __wl_hd=unknown
        __wl_md=unknown
    fi

    eval ${__wl_distro_str_out}="'${__wl_hd}'"
    eval ${__wl_distro_out}="'${__wl_md}'"
}

function version_to_major_minor()
{
    local __vtmm_version_str=${1}
    local __vtmm_major_ver_out=${2}
    local __vtmm_minor_ver_out=${3}

    local __vtmm_major_ver
    local __vtmm_minor_ver

    if [[ ${__vtmm_version_str} =~ ([[:digit:]]+)\.([[:digit:]]+) ]] ; then
        __vtmm_major_ver=${BASH_REMATCH[1]}
        __vtmm_minor_ver=${BASH_REMATCH[2]}
    elif [[ ${__vtmm_version_str} =~ ([[:digit:]]+) ]] ; then
        __vtmm_major_ver=${BASH_REMATCH[1]}
        __vtmm_minor_ver=0
    fi

    eval ${__vtmm_major_ver_out}="'${__vtmm_major_ver}'"
    eval ${__vtmm_minor_ver_out}="'${__vtmm_minor_ver}'"
}

#
# version_gt
#     lhs_major_version : in
#     lhs_minor_version : in
#     rhs_major_version : in
#     rhs_minor_version : in
#
# Returns shell true/false if the left hand side major/minor version pair is greater
# than the right hand side major/minor version pair.
#
function version_gt()
{
    local __vgt_lhs_major=${1}
    local __vgt_lhs_minor=${2}
    local __vgt_rhs_major=${3}
    local __vgt_rhs_minor=${4}

    if [[ ${__vgt_lhs_major} -gt ${__vgt_rhs_major} ]]; then
        return 0
    elif [[ ${__vgt_lhs_major} -eq ${__vgt_rhs_major} && \
            ${__vgt_lhs_minor} -gt ${__vgt_rhs_minor}  ]]; then
        return 0
    else
        return 1
    fi
}

#
# version_gte
#     lhs_major_version : in
#     lhs_minor_version : in
#     rhs_major_version : in
#     rhs_minor_version : in
#
# Returns shell true/false if the left hand side major/minor version pair is greater
# than or equal to the right hand side major/minor version pair.
#
function version_gte()
{
    local __vgt_lhs_major=${1}
    local __vgt_lhs_minor=${2}
    local __vgt_rhs_major=${3}
    local __vgt_rhs_minor=${4}

    if [[ ${__vgt_lhs_major} -gt ${__vgt_rhs_major} ]]; then
        return 0
    elif [[ ${__vgt_lhs_major} -eq ${__vgt_rhs_major} &&   \
            ( ${__vgt_lhs_minor} -gt ${__vgt_rhs_minor} || \
              ${__vgt_lhs_minor} -eq ${__vgt_rhs_minor} ) ]]; then
        return 0
    else
        return 1
    fi
}

#
# min_kernel_version
#     minimum_major_version : in
#     minimum_minor_version : in
#
# Returns shell true/false based on whether the currently running kernel meets the
# minimum version specified by the caller.
#
function min_kernel_ver()
{
    local __mkv_min_major=$1
    local __mkv_min_minor=$2
    local __mkv_kv_major
    local __mkv_kv_minor

    version_to_major_minor "$(uname -r)" __mkv_kv_major __mkv_kv_minor
    if version_gte ${__mkv_kv_major} ${__mkv_kv_minor} \
                   ${__mkv_min_major} ${__mkv_min_minor} ; then
        return 0
    else
        return 1
    fi
}

#
# get_kernel_cxl_options
#     config : in
#
# NOTE - This function relies on a global associative array called CXL_OPTIONS
#
# This function scans the kernel configuration file passed as an argument, looking
# for CXL options. It has a set of known variables that it is looking for but will
# add others to the array if they are found.
#
function get_kernel_cxl_options()
{
    local config=${1}

    eval CXL_OPTIONS[CONFIG_CXL_BUS]=""
    eval CXL_OPTIONS[CONFIG_CXL_PCI]=""
    eval CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS]=""
    eval CXL_OPTIONS[CONFIG_CXL_ACPI]=""
    eval CXL_OPTIONS[CONFIG_CXL_PMEM]=""
    eval CXL_OPTIONS[CONFIG_CXL_MEM]=""
    eval CXL_OPTIONS[CONFIG_CXL_PORT]=""
    eval CXL_OPTIONS[CONFIG_CXL_REGION]=""

    if [[ -f ${config} && -r ${config} ]]; then
        for setting in $(cat ${config} | grep CONFIG_CXL) ; do
            if [[ ${setting} =~ (CONFIG_CXL_[[:alpha:]]+)[[:space:]]*=[[:space:]]*([[:alnum:]]+) ]] ; then
                eval CXL_OPTIONS["${BASH_REMATCH[1]}"]=${BASH_REMATCH[2]}
            fi
        done
    fi
}

#
# deb_package_check
#     package_name       : in
#     package_installed  : out
#     package_version    : out
#     package_upgradable : out
#
# Checks whether the package given by the supplied name is installed and sets the second
# argument to 0/1 accordingly. If it is installed, then the third argument and fourth
# arguments respectively are set to the major and minor version of the package. The fifth
# argument is set to 0/1 if the package is-not/is currently upgradable
#
function deb_package_check()
{
    local __dpc_package_nm=$1
    local __dpc_installed_out=$2
    local __dpc_major_ver_out=$3
    local __dpc_minor_ver_out=$4
    local __dpc_upgradable_out=$5

    local __dpc_installed
    local __dpc_major_ver
    local __dpc_minor_ver
    local __dpc_upgradable
    
    if dpkg -s ${__dpc_package_nm} > /dev/null 2>&1 ; then
        __dpc_installed=1
    else
        __dpc_installed=0
        __dpc_major_ver=0
        __dpc_minor_ver=0
        __dpc_upgradable=0
    fi

    if (( ${__dpc_installed} == 1 )); then
        local __dpc_tmp=$(dpkg -s ${__dpc_package_nm} | grep Version | cut -d ' ' -f 2)
        if [[ ${__dpc_tmp} =~ ([0-9]+):(.*) ]] ; then
            # there is an epoch for the version, ignore it
            __dpc_tmp=${BASH_REMATCH[2]}
            if [[ ${__dpc_tmp} =~ (.*)-([[:alnum:]]*) ]] ; then
                # there a debian version string on the end, ignore it
                __dpc_tmp=${BASH_REMATCH[1]}
            fi
        fi

        version_to_major_minor ${__dpc_tmp} __dpc_major_ver __dpc_minor_ver

        if apt-get -s upgrade | grep ${__dpc_package_nm} > /dev/null 2>&1 ; then
           __dpc_upgradable=1
        else
           __dpc_upgradable=0
        fi
    fi

    eval ${__dpc_installed_out}="'${__dpc_installed}'"
    eval ${__dpc_major_ver_out}="'${__dpc_major_ver}'"
    eval ${__dpc_minor_ver_out}="'${__dpc_minor_ver}'"
    eval ${__dpc_upgradable_out}="'${__dpc_upgradable}'"
}

#
# rpm_check_upgradable
#     package_name          : in
#     package_major_version : in
#     package_minor_version : in
#
# Checks whether the package given by the supplied name is upgradable, defined as being
# Returns shell true/false if the package given by the supplied name is upgradable.
# A package is upgradable if dnf lists a version that is greater than the given version
#
function rpm_check_upgradable()
{
    local __rcu_package_nm=$1
    local __rcu_curr_major_ver=$2
    local __rcu_curr_minor_ver=$3

    local __rcu_tmp_major_ver
    local __rcu_tmp_minor_ver
    local __version

    for __version in $(dnf --showduplicates list --available  ${__rcu_package_nm} | \
                         grep ${__rcu_package_nm} 2>&1                            | \
                         tr -s " "                                                | \
                         cut -d ' ' -f 2)
    do
        version_to_major_minor ${__version} __rcu_tmp_major_ver __rcu_tmp_minor_ver
        if version_gt ${__rcu_tmp_major_ver}  ${__rcu_tmp_minor_ver} \
                      ${__rcu_curr_major_ver} ${__rcu_curr_major_ver} ; then
            return 0
        fi
    done

    return 1
}

#
# rpm_package_check
#     package_name       : in
#     package_installed  : out
#     package_version    : out
#     package_upgradable : out
#
# Checks whether the package given by the supplied name is installed and sets the second
# argument to 0/1 accordingly. If it is installed, then the third argument and fourth
# arguments respectively are set to the major and minor version of the package. The fifth
# argument is set to 0/1 if the package is-not/is currently upgradable
#
function rpm_package_check()
{
    local __rpc_package_nm=$1
    local __rpc_installed_out=$2
    local __rpc_major_ver_out=$3
    local __rpc_minor_ver_out=$4
    local __rpc_upgradable_out=$5

    local __rpc_installed
    local __rpc_major_ver
    local __rpc_minor_ver
    local __rpc_upgradable

    if rpm -q -s ${__rpc_package_nm} > /dev/null 2>&1 ; then
        __rpc_installed=1
    else
        __rpc_installed=0
        __rpc_major_ver=0
        __rpc_minor_ver=0
        __rpc_upgradable=0
    fi

    if (( ${__rpc_installed} == 1 )); then
        local __rpc_tmp=$(rpm -q --queryformat '%{VERSION}' ${__rpc_package_nm})
        if [[ ${__rpc_tmp} =~ ([[:digit:]]+).([[:digit:]]+) ]] ; then
            __rpc_major_ver=${BASH_REMATCH[1]}
            __rpc_minor_ver=${BASH_REMATCH[2]}
        elif [[ ${__rpc_tmp} =~ ([[:digit:]]+) ]] ; then
            __rpc_major_ver=${BASH_REMATCH[1]}
            __rpc_minor_ver=0
        fi

        if rpm_check_upgradable ${__rpc_package_nm} ${__rpc_major_ver} ${__rpc_minor_ver} ; then
            __rpc_upgradable=1
        else
            __rpc_upgradable=0
        fi
    fi

    eval ${__rpc_installed_out}="'${__rpc_installed}'"
    eval ${__rpc_major_ver_out}="'${__rpc_major_ver}'"
    eval ${__rpc_minor_ver_out}="'${__rpc_minor_ver}'"
    eval ${__rpc_upgradable_out}="'${__rpc_upgradable}'"
}

# ------------------------------------------------------------------------------------------------
# Utility Functions End (db4de81e-a31e-491d-a9dc-17a3e63be914)
# ------------------------------------------------------------------------------------------------



# ------------------------------------------------------------------------------------------------
#
# Primary Execution Sequence
#
# ------------------------------------------------------------------------------------------------

KERNEL_MAJOR_VER_MIN=5
KERNEL_MINOR_VER_MIN=12
KERNEL_VER_MIN_STR=${KERNEL_MAJOR_VER_MIN}.${KERNEL_MINOR_VER_MIN}

# Check if the system is running Linux
on_linux
if [ $? -ne 0 ]; then
    echo "${0} is only supported on Linux, exiting"
    exit 1
fi

# Set up the distro information
which_linux LINUX_DISTRO_STR LINUX_DISTRO
(( ${VERBOSE} == 1 )) && echo "Detected ${LINUX_DISTRO_STR}"
if (( ${STRICT} == 1 )); then
    if [ ${LINUX_DISTRO} != ubuntu -a ${LINUX_DISTRO} != fedora ]; then
        echo "Must be running one of Fedora or Ubuntu, exiting"
        exit 1
    fi
fi

# Check if the kernel meets the minimum version requirement
min_kernel_ver ${KERNEL_MAJOR_VER_MIN} ${KERNEL_MINOR_VER_MIN}
if [ $? -ne 0 ]; then
    echo "Minimum kernel version requirement not met:"
    exit 1
else
    (( ${VERBOSE} == 1 )) && echo "Minimum kernel version requirement met - $(uname -r) vs. ${KERNEL_VER_MIN_STR}"
fi

# Set kernel version and check for kernel boot configuration
KERN_VER=$(uname -r)
KERN_CFG=${ROOT_PREFIX}/boot/config-${KERN_VER}
if [[ ! -f ${KERN_CFG} ]]; then
    echo "Kernel boot configuraiton not in known location, expected ${KERN_CFG}"
    echo "    The kernel compile options are unknown"
    exit 1
else
    (( ${VERBOSE} == 1 )) && echo "Kernel boot configuration located (${KERN_CFG})"
fi

# Check to see whether we booted via UEFI or BIOS

if [[ ! -d ${ROOT_PREFIX}/sys/firmware/efi ]]; then
    UEFI_MODE=1
    (( ${VERBOSE} == 1 )) && echo "System booted using UEFI"
else
    UEFI_MODE=0
    (( ${VERBOSE} == 1 )) && echo "System booted using BIOS"
fi

# Attempt to obtain CXL options
declare -A CXL_OPTIONS
get_kernel_cxl_options ${KERN_CFG}

if (( ${VERBOSE} == 1 )) ; then
    if [[ ($CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS] == y) ||
          ($CXL_OPTIONS[CONFIG_CXL_MEM_RAW_COMMANDS] == m) ]] ; then
        echo "Standard and vendor-specific CXL mailbox commands may be used"
    else
        echo "Only standard CXL mailbox commands may be used"
    fi
fi

if [[ ${LINUX_DISTRO} == ubuntu ]]; then
    deb_package_check daxctll DAXCTL_PRESENT DAXCTL_MAJOR_VER DAXCTL_MINOR_VER DAXCTL_UPGRADABLE
else
    rpm_package_check daxctl DAXCTL_PRESENT DAXCTL_MAJOR_VER DAXCTL_MINOR_VER DAXCTL_UPGRADABLE
fi

if (( ${DAXCTL_PRESENT} == 0 )) ; then
    echo "The package daxctl does not appear to be installed. Please install the latest version."
else
    echo "daxctl version: ${DAXCTL_MAJOR_VER}.${DAXCTL_MINOR_VER}"
fi
